# Problem Set 2

# Vanilla Logit
### Q1: Derive estimating equations

Consider the logit model given by

$$\begin{aligned} u_{ijt} &= \delta^*_{jt} + \epsilon_{ijt} \\
\delta^*_{jt} &= x_{jt}\beta - \alpha p_{jt} + \xi_{jt}\end{aligned}$$

where $\epsilon_{ijt}$ is i.i.d. extreme value. First, we estimate each year separately. Under this assumption, the conditional choice probability is given by

$$S_{jt} = \frac{\exp(x_{jt}\beta_t - \alpha_t p_{jt} + \xi_{jt})}{\sum_{k=1}^J \exp(x_{kt}\beta_t - \alpha_t p_{kt} + \xi_{kt})}$$

Note that the coefficients are indexed by year $t$. To proceed, I normalize the utility of the outside option to $\xi_{0t} = 0$. Then, I divide by the choice probability of the outside option and take logs to obtain

$$\ln(S_{jt}) = x_{jt}\beta_t - \alpha_t p_{jt} - \ln(S_{0t}) + \xi_{jt}$$

### Q2
If we pool the data across years, the derivation would exclude the subscript $t$ on $\alpha$ and $\beta$.

### Q3
I estimate the demand system parameters by GMM using only demand-side moment conditions. Because price is endogenous, I construct an instrument $Z_{jt}$ using BLP instruments (i.e., the characteristics of competing products in a given year).

```{r results='hide'}
rm(list = ls())
library(here)
library(data.table)

# Import ----
dt <- fread(here("Mortimer HW", "data", "ps2_data_3nests.txt"))
setnames(dt, c(
    "car_id", "year", "firm_id", "price", "quantity",
    "weight", "hp", "ac", "nest3"
))

M <- 100 * 10^6 # market size

# Normalize weight, horsepower, and price by dividing by their
# respective means
v_norm <- c("weight", "hp", "price")
dt[, (v_norm) := lapply(.SD, function(x) x / mean(x)), .SDcols = v_norm]

dt[, const := 1]
dt[, share := quantity / M]

# Construct BLP instruments for price using the characteristics
# of competing products within each year
v_char <- c("weight", "hp", "ac")
dt[, paste0("z_", v_char) := lapply(
    .SD,
    function(x) sum(x) - x
), by = year, .SDcols = v_char]

```

```{r}
# Estimate demand paramters by GMM
v_instr <- paste0("z_", v_char)
v_cov <- c("price", v_char, "const")
Y <- as.matrix(dt$share)
X <- as.matrix(dt[, ..v_cov])
Z <- as.matrix(dt[, ..v_instr])

n_moments <- ncol(Z)

# starting beta value
b_start <- solve(t(X) %*% X) %*% t(X) %*% Y

W <- diag(n_moments) # weighting matrix

objGMM <- function(b, W, X, Y, Z) {
    nObs <- nrow(Y)
    vAvgMom <- (1 / nObs) * (t(Z)) %*% (Y - X %*% b)

    return(nObs * t(vAvgMom) %*% W %*% vAvgMom)
}

# First step of GMM
b_hat_gmm <- optim(b_start, objGMM,
    W = W, X = X, Y = Y, Z = Z, method = "BFGS",
    control = list(maxit = 1e5, reltol = 1e-12)
)
ep_hat_gmm <- Y - X %*% b_hat_gmm$par

# Get optimal weight matrix
s_hat <- solve((1 / nrow(Y)) * t(Z) %*%
    diag(diag(ep_hat_gmm %*% t(ep_hat_gmm))) %*% Z)

# Second step of GMM
b_hat_gmm_e <- optim(b_hat_gmm$par, objGMM,
    W = s_hat, X = X, Y = Y, Z = Z,
    method = "BFGS",
    control = list(maxit = 10000, reltol = 1e-12)
)

# Find s^2
epsilon <- Y - X %*% b_hat_gmm_e$par
s_squared <- t(epsilon) %*% epsilon / (nrow(Y) - length(b_hat_gmm_e$par))

## Find Standard Errors
se_ols <- sqrt(diag(s_squared[1] * solve(t(X) %*% X)))

final <- as.data.frame(t(cbind(b_hat_gmm_e$par, se_ols)))
row.names(final) <- c("2 step GMM: ", "SE: ")
colnames(final) <- v_cov
final
```

### Q4
I compute the own and cross-price derivatives

$$\begin{aligned}
\frac{\partial S_{jt}}{\partial p_{jt}} &= \alpha_tS_{jt}(S_{jt}-1) \\
\frac{\partial S_{jt}}{\partial p_{kt}} &= \alpha_tS_{jt}S_{kt}
\end{aligned}$$

```{r}
## Cross-Price Elasticites
setorder(dt, -quantity)

dt_top10 <- head(dt[year == 1990], 10)
alpha <- b_hat_gmm_e$par[1]

# Compute the matrix of elasticities
dt_elas <- CJ(
    own_product = dt_top10$car_id,
    cross_product = dt_top10$car_id
)

dt_elas <- merge(dt_elas, dt_top10[, .(car_id, price, share)],
    by.x = "own_product", by.y = "car_id"
)
dt_elas <- merge(dt_elas, dt_top10[, .(car_id, price, share)],
    by.x = "cross_product", by.y = "car_id"
)
dt_elas[
    own_product == cross_product,
    price_elas := alpha * price.x * (share.x - 1)
]
dt_elas[own_product != cross_product, price_elas := alpha * price.y * share.y]

dcast(dt_elas, own_product ~ cross_product, value.var = "price_elas")
```

# Nested Logit
### Q5

**a)** The market share for a single product in a nested logit model is given by the product of the group choice probability and the within-group choice probability

$$S_{j} = \frac{\exp(\delta^*_j/(1-\sigma))}{D_g^{\sigma}\left[\sum_gD_g^{1-\sigma}\right]}$$

where $$D_g = \sum_{j \in \mathcal{J}_g}\exp(\delta_j^*/(1-\sigma))$$ is the group choice probability.

**b)** Solving for $\delta_j^*$ under the assumption that the outside option is normalized to zero, I obtain

$$\delta_j^* = \ln S_j + \sigma \ln D_g + \ln \left[\sum_g D_g^{1-\sigma}\right]$$

**c)** The market share for a single product in the nested logit model after the Berry (1994) inversion is given by

$$\ln S_j = x_j\beta - \alpha p_j + \sigma \ln (\bar{S}_{j|g}) + \ln S_0 + \xi_j$$

where $\bar{S}_{j|g}$ is the within-group market share of $j$ and $S_0$ is the share of the outside option.

### Q6

**a)** The nested logit relaxes the IIA assumption of the nested logit, allowing for substitution patterns that are *not* proportional to shares.

**b)** All forms of nested logit suffer from ``too much'' mass in the tails. Regardless of the product's characteristics, there will always be some consumers whose $\xi$ is sufficiently large to make the product their most preferred option. In short: crummy products get bought too much.

### Q7







